<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">























  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Gloria Hallelujah:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png?v=6.7.0">


  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg?v=6.7.0" color="#222">


  <link rel="manifest" href="/icons/manifest.json">


  <meta name="msapplication-config" content="/icons/browserconfig.xml">





<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.7.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content=".image-captain {     margin-top: -20px; } .marked-code {     color:red;     font-weight:bold; }  子查询（Subquery）的优化一直以来都是 SQL 查询优化中的难点之一。关联子查询的基本执行方式类似于 Nested-Loop，但是这种执行方式的效率常常低到难以忍受。当数据量稍大时，必须在优化器中">
<meta name="keywords" content="selected,database,optimizer,sql">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL 子查询的优化">
<meta property="og:url" content="https://ericfu.me/subquery-optimization/index.html">
<meta property="og:site_name" content="Coding Husky">
<meta property="og:description" content=".image-captain {     margin-top: -20px; } .marked-code {     color:red;     font-weight:bold; }  子查询（Subquery）的优化一直以来都是 SQL 查询优化中的难点之一。关联子查询的基本执行方式类似于 Nested-Loop，但是这种执行方式的效率常常低到难以忍受。当数据量稍大时，必须在优化器中">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ericfu.me/images/2019/04/banner-subquery-optimization.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-optimization-query-1-relnode-1.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-optimization-query-apply-operator.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-optimization-subquery-using-apply.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/convert-subquery-to-apply.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/rule-set-1.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-decorrlation-rule-set-1-example.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/rule-set-2-1.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-decorration-project-filter-rules%20-1-.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-decorrlation-rule-set-2-example.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/rule-set-3.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-decorrelation-agg-example.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/rule-set-4.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/subquery-decorration-set-op-rules.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/hyper-outer-join-example.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/hyper-general-unnesting.png">
<meta property="og:image" content="https://ericfu.me/images/2019/04/hyper-general-unnesting-example.png">
<meta property="og:updated_time" content="2019-08-21T15:23:23.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SQL 子查询的优化">
<meta name="twitter:description" content=".image-captain {     margin-top: -20px; } .marked-code {     color:red;     font-weight:bold; }  子查询（Subquery）的优化一直以来都是 SQL 查询优化中的难点之一。关联子查询的基本执行方式类似于 Nested-Loop，但是这种执行方式的效率常常低到难以忍受。当数据量稍大时，必须在优化器中">
<meta name="twitter:image" content="https://ericfu.me/images/2019/04/banner-subquery-optimization.png">






  <link rel="canonical" href="https://ericfu.me/subquery-optimization/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>SQL 子查询的优化 | Coding Husky</title>
  




  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-71209065-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-71209065-1');
  </script>









  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding Husky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ericfu.me/subquery-optimization/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Fu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/2015/12/HuskyAvatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Husky">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">SQL 子查询的优化

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-20 17:04:53" itemprop="dateCreated datePublished" datetime="2019-03-20T17:04:53+08:00">2019-03-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-21 23:23:23" itemprop="dateModified" datetime="2019-08-21T23:23:23+08:00">2019-08-21</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/subquery-optimization/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="subquery-optimization/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/images/2019/04/banner-subquery-optimization.png"></p>
<style type="text/css">
.image-captain {
    margin-top: -20px;
}
.marked-code {
    color:red;
    font-weight:bold;
}
</style>
<p><strong>子查询</strong>（Subquery）的优化一直以来都是 SQL 查询优化中的难点之一。关联子查询的基本执行方式类似于 Nested-Loop，但是这种执行方式的效率常常低到难以忍受。当数据量稍大时，必须在优化器中对其进行<strong>去关联化</strong>（Decoorelation 或 Unnesting），将其改写为类似于 Semi-Join 这样的更高效的算子。</p>
<p>前人已经总结出一套完整的方法论，理论上能对任意一个查询进行去关联化。本文结合 SQL Server 以及 HyPer 的几篇经典论文，由浅入深地讲解一下这套去关联化的理论体系。它们二者所用的方法大同小异，基本思想是想通的。</p>
<a id="more"></a>
<p>本文的例子都基于 TPC-H 的表结构，<a href="/images/2019/04/The-TPC-H-Schema.png">这里</a> 有一份供你参考。</p>
<h2 id="子查询简介">子查询简介</h2>
<p>子查询是定义在 SQL 标准中一种语法，它可以出现在 SQL 的几乎任何地方，包括 SELECT, FROM, WHERE 等子句中。</p>
<p>总的来说，子查询可以分为<strong>关联子查询（Correlated Subquery）</strong>和<strong>非关联子查询（Non-correlated Subquery）</strong>。后者非关联子查询是个很简单的问题，最简单地，只要先执行它、得到结果集并物化，再执行外层查询即可。下面是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c_count, <span class="keyword">count</span>(*) <span class="keyword">AS</span> custdist</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">     <span class="keyword">SELECT</span> c_custkey, <span class="keyword">count</span>(o_orderkey) <span class="keyword">AS</span> c_count</span><br><span class="line">     <span class="keyword">FROM</span> CUSTOMER</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> ORDERS <span class="keyword">ON</span> c_custkey = o_custkey</span><br><span class="line">     <span class="keyword">AND</span> o_comment <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">'%pending%deposits%'</span></span><br><span class="line">     <span class="keyword">GROUP</span> <span class="keyword">BY</span> c_custkey</span><br><span class="line">     ) c_orders</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c_count</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> custdist <span class="keyword">DESC</span>, c_count <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p class="image-captain">
▲ TPCH-13 是一个非关联子查询
</p>
<p><strong>非关联子查询不在本文讨论范围之列</strong>，除非特别声明，以下我们说的子查询都是指关联子查询。</p>
<p>关联子查询的特别之处在于，其本身是不完整的：<strong>它的闭包中包含一些外层查询提供的参数</strong>。显然，只有知道这些参数才能运行该查询，所以我们不能像对待非关联子查询那样。</p>
<p>根据产生的数据来分类，子查询可以分成以下几种：</p>
<p><strong>标量（Scalar-valued）</strong>子查询：输出一个只有一行一列的结果表，这个标量值就是它的结果。如果结果为空（0 行），则输出一个 NULL。但是注意，超过 1 行结果是不被允许的，会产生一个运行时异常。</p>
<p>标量子查询可以出现在任意包含标量的地方，例如 SELECT、WHERE 等子句里。下面是一个例子：</p>
<pre><code>SELECT c_custkey
FROM CUSTOMER
WHERE 1000000 < (
    SELECT SUM(o_totalprice)
    FROM ORDERS
    WHERE o_custkey = <span class="marked-code">c_custkey</span>
)
</code></pre>
<p class="image-captain">
▲ Query 1: 一个出现在 WHERE 子句中的标量子查询，关联参数用红色字体标明了
</p>
<pre><code>SELECT o_orderkey, (
    SELECT c_name
    FROM CUSTOMER
    WHERE c_custkey = <span class="marked-code">o_custkey</span>
) AS c_name FROM ORDERS
</code></pre>
<p class="image-captain">
▲ Query 2: 一个出现在 SELECT 子句中的标量子查询
</p>
<p><strong>存在性检测（Existential Test）</strong>子查询：特指 EXISTS 的子查询，返回一个布尔值。如果出现在 WHERE 中，这就是我们熟悉的 Semi-Join。当然，它可能出现在任何可以放布尔值的地方。</p>
<pre><code>SELECT c_custkey
FROM CUSTOMER
WHERE c_nationkey = 86 AND EXISTS(
    SELECT * FROM ORDERS
    WHERE o_custkey = <span class="marked-code">c_custkey</span>
)
</code></pre>
<p class="image-captain">
▲ Query 3: 一个 Semi-Join 的例子
</p>
<p><strong>集合比较（Quantified Comparision）</strong>子查询：特指 IN、SOME、ANY 的查询，返回一个布尔值，常用的形式有：<code>x = SOME(Q)</code> （等价于 <code>x IN Q</code>）或 <code>X &lt;&gt; ALL(Q)</code>（等价于 <code>x NOT IN Q</code>）。同上，它可能出现在任何可以放布尔值的地方。</p>
<pre><code>SELECT c_name
FROM CUSTOMER
WHERE c_nationkey <> ALL (SELECT s_nationkey FROM SUPPLIER)
</code></pre>
<p class="image-captain">
▲ Query 4: 一个集合比较的非关联子查询
</p>
<h2 id="原始执行计划">原始执行计划</h2>
<p>我们以 Query 1 为例，直观地感受一下，为什么说关联子查询的去关联化是十分必要的。</p>
<p>下面是 Query 1 的未经去关联化的原始查询计划（Relation Tree）。与其他查询计划不一样的是，我们特地画出了表达式树（Expression Tree），可以清晰地看到：子查询是实际上是挂在 Filter 的条件表达式下面的。</p>
<p><img src="/images/2019/04/subquery-optimization-query-1-relnode-1.png"></p>
<p>实际执行时，查询计划执行器（Executor）在执行到 Filter 时，调用表达式执行器（Evaluator）；由于这个条件表达式中包含一个标量子查询，所以 Evaluator 又会调用 Executor 计算标量子查询的结果。</p>
<p><strong>这种 Executor - Evaluator - Executor 的交替调用十分低效</strong>！考虑到 Filter 上可能会有上百万行数据经过，如果为每行数据都执行一次子查询，那查询执行的总时长显然是不可接受的。</p>
<h2 id="apply-算子">Apply 算子</h2>
<p>上文说到的 Relation - Expression - Relation 这种交替引用不仅执行性能堪忧，而且，对于优化器也是个麻烦的存在——我们的优化规则都是在匹配并且对 Relation 进行变换，而这里的子查询却藏在 Expression 里，令人无从下手。</p>
<p>为此，在开始去关联化之前，我们引入 Apply 算子：</p>
<p><strong>Apply 算子</strong>（也称作 Correlated Join）接收两个关系树的输入，与一般 Join 不同的是，Apply 的 Inner 输入（图中是右子树）是一个带有参数的关系树。</p>
<p>Apply 的含义用下图右半部分的集合表达式定义：对于 Outer Relation <span class="math inline">\(R\)</span> 中的每一条数据 <span class="math inline">\(r\)</span>，计算 Inner Relation <span class="math inline">\(E(r)\)</span>，输出它们连接（Join）起来的结果 <span class="math inline">\({r} \otimes E(r)\)</span>。Apply 的结果是所有这些结果的并集（本文中说的并集指的是 Bag 语义下的并集，也就是 UNION ALL）。</p>
<p><img src="/images/2019/04/subquery-optimization-query-apply-operator.png"></p>
<blockquote>
<p>Apply 是 SQL Server 的命名，它在 HyPer 的文章中叫做 Correlated Join。它们是完全等价的。考虑到 SQL Server 的文章发表更早、影响更广，本文中都沿用它的命名。</p>
</blockquote>
<p>根据连接方式（<span class="math inline">\(\otimes\)</span>）的不同，Apply 又有 4 种形式：</p>
<ul>
<li><strong>Cross Apply</strong> <span class="math inline">\(A^{\times}\)</span>：这是最基本的形式，行为刚刚我们已经描述过了；</li>
<li><strong>Left Outer Apply</strong> <span class="math inline">\(A^{LOJ}\)</span>：即使 <span class="math inline">\(E(r)\)</span> 为空，也生成一个 <span class="math inline">\(r \circ \{NULLs\}\)</span>。</li>
<li><strong>Semi Apply</strong> <span class="math inline">\(A^{\exists}\)</span>：如果 <span class="math inline">\(E(r)\)</span> 不为空则返回 <span class="math inline">\(r\)</span>，否则丢弃；</li>
<li><strong>Anti-Semi Apply</strong> <span class="math inline">\(A^{\nexists}\)</span>：如果 <span class="math inline">\(E(r)\)</span> 为空则返回 <span class="math inline">\(r\)</span>，否则丢弃；</li>
</ul>
<p>我们用刚刚定义的 Apply 算子来改写之前的例子：把子查询从 Expression 内部提取出来。结果如下：</p>
<p><img src="/images/2019/04/subquery-optimization-subquery-using-apply.png"></p>
<p>上面的例子中，我们可以肯定 Scalar Agg 子查询<strong>有且只有</strong>一行结果，所以可以直接转成 Apply。但某些情况下，可能无法肯定子查询一定能返回 0 或 1 行结果（例如，想象一下 Query 2 如果 c_custkey 不是唯一的），为了确保 SQL 语义，还要在 Apply 右边加一个 <span class="math inline">\(\textit{Max1Row}\)</span> 算子：</p>
<p><span class="math display">\[
\textit{Max1Row}(E)=
\begin{cases}
    \textit{Null}, &amp; \text{if}\ |E|=0 \\
    E, &amp; \text{if}\ |E|=1 \\
    \textit{error}, &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>理论上，我们<strong>可以将所有的子查询转换成 Apply 算子</strong>，一个通用的方法如下：</p>
<ol type="1">
<li>如果某个算子的表达式中出现了子查询，我们就把这个子查询提取到该算子下面（留下一个子查询的结果变量），构成一个 <span class="math inline">\(A^{LOJ}\)</span> 算子。如果不止一个子查询，则会产生多个 <span class="math inline">\(A^{LOJ}\)</span>。必要的时候加上 <span class="math inline">\(\textit{Max1Row}\)</span> 算子。</li>
<li>然后应用其他一些规则，将 <span class="math inline">\(A^{LOJ}\)</span> 转换成 <span class="math inline">\(A^{\times}\)</span>、<span class="math inline">\(A^{\exists}\)</span>、<span class="math inline">\(A^{\nexists}\)</span>。例如上面例子中的子查询结果 <span class="math inline">\(X\)</span> 被用作 Filter 的过滤条件，NULL 值会被过滤掉，因此可以安全地转换成 <span class="math inline">\(A^{\times}\)</span>。</li>
</ol>
<p>下面这个例子中，Filter 条件表达式中包含 <span class="math inline">\(Q_1\)</span>、<span class="math inline">\(Q_2\)</span> 两个子查询。转换之后分别生成了对应的 Apply 算子。其中 <span class="math inline">\(Q_2\)</span> 无法确定只会生成恰好一条记录，所以还加上了 <span class="math inline">\(\textit{Max1Row}\)</span> 算子。</p>
<p><img src="/images/2019/04/convert-subquery-to-apply.png"></p>
<h2 id="基本消除规则">基本消除规则</h2>
<p>第一组规则是最基本的规则，等式中的 <span class="math inline">\(\otimes\)</span> 说明它不限制连接类型，可以是 <span class="math inline">\(\{ \times, LOJ, \exists, \nexists \}\)</span> 中的任意一个。</p>
<p><img src="/images/2019/04/rule-set-1.png"></p>
<p>这两条规则是非常显而易见的，翻译成大白话就是：如果 Apply 的右边不包含来自左边的参数，那它就和直接 Join 是等价的。</p>
<p>下面是对 Query 3 应用规则 (2) 的例子：</p>
<p><img src="/images/2019/04/subquery-decorrlation-rule-set-1-example.png"></p>
<h2 id="project-和-filter-的去关联化">Project 和 Filter 的去关联化</h2>
<p>第二组规则描述了如何处理子查询中的 Project 和 Filter，其思想可以用一句话来描述：<strong>尽可能把 Apply 往下推、把 Apply 下面的算子向上提</strong>。</p>
<p><img src="/images/2019/04/rule-set-2-1.png"></p>
<p><img src="/images/2019/04/subquery-decorration-project-filter-rules%20-1-.png"></p>
<p>注意这些规则仅处理 Cross Apply 这一种情况。其他 3 种 Apply 的变体，理论上都可以转换成 Cross Apply，暂时我们只要知道这个事实就可以了。</p>
<p>你可能会问：通常我们都是尽可能把 Filter、Project 往下推，为什么这里会反其道而行呢？关键在于：Filter、Project 里面原本包含了带有关联变量的表达式，但是把它提到 Apply 上方之后，<strong>关联变量就变成普通变量了！</strong>这正是我们想要的。</p>
<p>我们稍后就会看到这样做的巨大收益：<strong>当 Apply 被推最下面时，就可以应用第一组规则，直接把 Apply 变成 Join</strong>，也就完成了子查询去关联化的优化过程。</p>
<p>下面是对 Query 2 应用规则 (3) 的例子。之后再应用规则 (1)，就完成了去关联化过程。</p>
<p><img src="/images/2019/04/subquery-decorrlation-rule-set-2-example.png"></p>
<h2 id="aggregate-的去关联化">Aggregate 的去关联化</h2>
<p>第三组规则描述如何处理子查询中的 Aggregate（即 Group By）。和上一组一样，我们的指导思想仍然是：<strong>尽可能把 Apply 往下推、把 Apply 下面的算子向上提</strong>。</p>
<p>下面等式中，<span class="math inline">\(G_{A,F}\)</span> 表示带有 Group By 分组的聚合（Group Agg），其中 <span class="math inline">\(A\)</span> 表示分组的列，<span class="math inline">\(F\)</span> 表示聚合函数的列；<span class="math inline">\(G_{F}^{1}\)</span> 表示不带有分组的聚合（Scalar Agg）。</p>
<p><img src="/images/2019/04/rule-set-3.png"></p>
<p>这一组规则不像之前那么简单直白，我们先看一个例子找找感觉。下面是对 Query 1 运用规则 (9) 的结果：</p>
<p><img src="/images/2019/04/subquery-decorrelation-agg-example.png"></p>
<p>规则 (9) 在下推 Apply 的同时，还将 ScalarAgg 变成了 GroupAgg，其中，<strong>分组列就是 R 的 key</strong>，在这里也就是 CUSTOMER 的主键 c_custkey。</p>
<blockquote>
<p>如果 R 没有主键或唯一键，理论上，我们可以在 Scan 时生成一个。</p>
</blockquote>
<p>为什么变换前后是等价的呢？变换前，我们是给每个 R 的行做了一次 ScalarAgg 聚合计算，然后再把聚合的结果合并起来；变换后，我们先是将所有要聚合的数据准备好（这被称为 augment），然后使用 GroupAgg 一次性地做完所有聚合。</p>
<p>这也解释了为什么我们要用 <span class="math inline">\(A^{LOJ}\)</span> 而不是原本的 <span class="math inline">\(A^{\times}\)</span> ：原来的 ScalarAgg 上，即使输入是空集，也会输出一个 NULL。如果我们这里用 <span class="math inline">\(A^{LOJ}\)</span>，恰好也会得到一样的行为（＊）；反之，如果用 <span class="math inline">\(A^{\times}\)</span> 就有问题了——没有对应 ORDERS 的客户在结果中消失了！</p>
<p>规则 (8) 处理的是 GroupAgg，道理也是一样的，只不过原来的分组列也要留着。</p>
<p><strong>ScalarAgg 转换中的细节＊</strong></p>
<p>细心的读者可能注意到，规则 (9) 右边产生的聚合函数是 <span class="math inline">\(F&#39;\)</span>，多了一个单引号，这暗示它和原来的聚合函数 <span class="math inline">\(F\)</span> 可能是有些不同的。那什么情况下会不同呢？这个话题比较深入了，不感兴趣的同学可以跳过。</p>
<p>首先我们思考下，GroupAgg 以及 <span class="math inline">\(A^{LOJ}\)</span> 的行为真的和变换前一模一样吗？其实不然。举个反例：</p>
<pre><code class="language-text">SELECT c_custkey, (
    SELECT <span class="marked-code">COUNT(*)</span>
    FROM ORDERS
    WHERE o_custkey = c_custkey
) AS count_orders
FROM CUSTOMER
</code></pre>
<p>设想一下：客户 Eric 没有任何订单，那么这个查询应当返回一个 <code>['Eric', 0]</code> 的行。但是，当我们应用了规则 (9) 做变换之后，却得到了一个 <code>['Eric', 1]</code> 的值，结果出错了！</p>
<p>为何会这样呢？变换之后，我们是先用 LeftOuterJoin 准备好中间数据（augment），然后用 GroupAgg 做聚合。LeftOuterJoin 为客户 Eric 生成了一个 <code>['Eric', NULL, NULL, ...]</code> 的行；之后的 GroupAgg 中，聚合函数 <code>COUNT(*)</code> 认为 Eric 这个分组有 1 行数据，所以输出了 <code>['Eric', 1]</code>。</p>
<p>下面是个更复杂的例子，也有类似的问题：</p>
<pre><code class="language-text">SELECT c_custkey
FROM CUSTOMER
WHERE 200000 < (
    SELECT <span class="marked-code">MAX(IF_NULL(o_totalprice, 42))</span> -- o_totalprice may be NULL
    FROM ORDERS
    WHERE o_custkey = c_custkey
)
</code></pre>
<p>作为总结，问题的根源在于：<span class="math inline">\(F(\emptyset) \neq F(\{\textit{NULL}\})\)</span>，这样的聚合函数 <span class="math inline">\(F\)</span> 都有这个问题。</p>
<p><strong>变换后的 GroupAgg 无法区分它看到的 NULL 数据到底是 OuterJoin 产生的，还是原本就存在的</strong>，有时候，这两种情形在变换前的 ScalarAgg 中会产生不同的结果。</p>
<p>幸运的是，SQL 标准中定义的聚合函数 <span class="math inline">\(F(col)\)</span> 都是 OK 的——它们都满足 <span class="math inline">\(F(\emptyset) = F(\{\textit{NULL}\})\)</span>，我们只要对 <span class="math inline">\(F\)</span> 稍加变换就能解决这个问题。</p>
<ul>
<li>对于例子一，将 <code>COUNT(*)</code> 替换成一个对非空列（例如主键）的 Count 即可，例如：<code>COUNT(o_orderkey)</code>；</li>
<li>对于例子二，需要把 <code>MIN(IF_NULL(o_totalprice, 42))</code> 分成两步来做：定义中间变量 <code>X</code>，先用 Project 计算 <code>X = IF_NULL(o_totalprice, 42)</code>，再对聚合函数 <code>MIN(X)</code> 进行去关联化即可。</li>
</ul>
<h2 id="集合运算的去关联化">集合运算的去关联化</h2>
<p>最后一组优化规则用来处理带有 Union（对应 <code>UNION ALL</code>）、Subtract（对应 <code>EXCEPT ALL</code>） 和 Inner Join 算子的子查询。再强调一遍，我们的指导思想是：<strong>尽可能把 Apply 往下推、把 Apply 下面的算子向上提</strong>。</p>
<p>下面的等式中，<span class="math inline">\(\times\)</span> 表示 Cross Join，<span class="math inline">\(\bowtie_{R.key}\)</span> 表示按照 <span class="math inline">\(R\)</span> 的 Key 做自然连接：<span class="math inline">\(r \circ e_1 \circ e_2\)</span> 。和之前一样，我们假设 <span class="math inline">\(R\)</span> 存在主键或唯一键，如果没有也可以在 Scan 的时候加上一个。</p>
<p><img src="/images/2019/04/rule-set-4.png"></p>
<p><img src="/images/2019/04/subquery-decorration-set-op-rules.png"></p>
<p>注意到，这些规则与之前我们见过的规则有个显著的不同：等式右边 <span class="math inline">\(R\)</span> 出现了两次。这样一来，要么我们把这颗子树拷贝一份，要么做成一个 DAG 的执行计划，总之会麻烦许多。</p>
<p>事实上，这一组规则很少能派上用场。在 [2] 中提到，在 TPC-H 的 Schema 下甚至很难写出一个带有 Union All 的、有意义的子查询。</p>
<h2 id="其他">其他</h2>
<p>有几个我认为比较重要的点，用 FAQ 的形式列在下面。</p>
<p><strong>► 是否任意的关联子查询都可以被去关联化？</strong></p>
<p>可以说是这样的，在加上少量限定之后，理论上可以证明：任意的关联子查询都可以被去关联化。</p>
<p>证明方法在 [1]、[3] 中都有提及。以 [1] 中为例，思路大致是：</p>
<ol type="1">
<li>对于任意的查询关系树，首先将关联子查询从表达式中提取出来，用 Apply 算子表示；</li>
<li>一步步去掉其中非基本关系算子，首先，通过等价变换去掉 Union 和 Subtract；</li>
<li>进一步缩小算子集合，去掉 OuterJoin、<span class="math inline">\(A^{LOJ}\)</span>、<span class="math inline">\(A^{\exists}\)</span>、<span class="math inline">\(A^{\nexists}\)</span>；</li>
<li>最后，去掉所有的 <span class="math inline">\(A^{\times}\)</span>，剩下的关系树仅包含基本的一些关系算子，即完成了去关联化。</li>
</ol>
<p>另一方面，现实世界中用户使用的子查询大多是比较简单的，本文中描述的这些规则可能已经覆盖到 99% 的场景。虽然理论上任意子查询都可以处理，但是实际上，没有任何一个已知的 DBMS 实现了所有这些变换规则。</p>
<p><strong>► HyPer 和 SQL Server 的做法有什么异同？</strong></p>
<p>HyPer 的理论覆盖了更多的去关联化场景。例如各种 Join 等算子，[3] 中都给出了相应的等价变换规则（作为例子，下图是对 Outer Join 的变换）。而在 [1] 中仅仅是证明了这些情况都可以被规约到可处理的情形（实际上嘛，可想而知，一定是没有处理的）。</p>
<p><img src="/images/2019/04/hyper-outer-join-example.png"></p>
<p>另一个细节是，HyPer 中还存在这样一条规则：</p>
<p><img src="/images/2019/04/hyper-general-unnesting.png"></p>
<p>其中，<span class="math inline">\(D=\Pi_{F(T_2)\cap A(T_1)} (T_1)\)</span>，表示对 <span class="math inline">\(T_1\)</span> 的 Distinct Project 结果（所谓的 <em>Magic Set</em>）。直接看等式比较晦涩，看下面的例子就容易理解了：</p>
<p><img src="/images/2019/04/hyper-general-unnesting-example.png"></p>
<p>图中，在做 Apply 之前，先拿到需要 Apply 的列的 Distinct 值集合，拿这些值做 Apply，之后再用普通的 Join 把 Apply 的结果连接上去。</p>
<p>这样做的好处是：如果被 Apply 的数据存在大量重复，则 Distinct Project 之后需要 Apply 的行数大大减少。这样一来，即使之后 Apply 没有被优化掉，迭代执行的代价也会减小不少。</p>
<p><strong>► 本文说的这些变换规则，应该用在 RBO 还是 CBO 中呢？换句话说，去关联化后之后的执行计划一定比去关联化之前更好吗？</strong></p>
<p>答案是，不一定。</p>
<p>直观的看，如果 Apply 的左边数据量比较少（例如，仅有 1 条数据），那直接带入 Apply 的右边计算反而是更好的方式。另一种情况是，右边有合适的索引，这种情况下，多次 Apply 的代价也并非不可接受。</p>
<p>所以把这些规则放进一个 CBO 的优化器是更合适的，优化器根据代价估计选出最优的计划来。甚至，在某些情况下，我们还会自右向左地运用这些等式，做“加关联化”。</p>
<p>这和用 HashJoin 还是 NestedLoopJoin 是同样的道理。事实上，NestedLoopJoin 就是 Apply 的一个特例。如果存在合适的索引，NestedLoopJoin 效率高于 HashJoin 是很常见的事情。</p>
<h2 id="references">References</h2>
<ol type="1">
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2000-31.pdf" target="_blank" rel="noopener">Parameterized Queries and Nesting Equivalencies - C Galindo-Legaria</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.563.8492&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">Orthogonal Optimization of Subqueries and Aggregation - C Galindo-Legaria, M Joshi</a></li>
<li><a href="https://dl.gi.de/bitstream/handle/20.500.12116/2418/383.pdf?sequence=1" target="_blank" rel="noopener">Unnesting Arbitrary Queries - T Neumann, A Kemper</a></li>
<li><a href="https://dl.gi.de/bitstream/handle/20.500.12116/657/paper04.pdf?sequence=1&amp;isAllowed=y" target="_blank" rel="noopener">The Complete Story of Joins (inHyPer) - T Neumann, V Leis, A Kemper</a></li>
</ol>

      
    </div>

    

    
    
    

    

    
      
    
    

    
      <div>
        



  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Eric Fu</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="https://ericfu.me/subquery-optimization/" title="SQL 子查询的优化">https://ericfu.me/subquery-optimization/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/selected/" rel="tag"># selected</a>
          
            <a href="/tags/database/" rel="tag"># database</a>
          
            <a href="/tags/optimizer/" rel="tag"># optimizer</a>
          
            <a href="/tags/sql/" rel="tag"># sql</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/code-gen-of-query/" rel="next" title="JIT 代码生成技术（二）查询编译执行">
                <i class="fa fa-chevron-left"></i> JIT 代码生成技术（二）查询编译执行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/sql-window-function/" rel="prev" title="SQL 窗口函数的优化和执行">
                SQL 窗口函数的优化和执行 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/2015/12/HuskyAvatar.jpg" alt="Eric Fu">
            
              <p class="site-author-name" itemprop="name">Eric Fu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">93</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/fuyufjh" title="GitHub &rarr; https://github.com/fuyufjh" rel="noopener" target="_blank"><i class="iconfont icon-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/fuyufjh" title="Zhihu &rarr; https://www.zhihu.com/people/fuyufjh" rel="noopener" target="_blank"><i class="iconfont icon-zhihu"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://twitter.com/fuyufjh" title="Twitter &rarr; https://twitter.com/fuyufjh" rel="noopener" target="_blank"><i class="iconfont icon-twitter"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://www.linkedin.com/in/njufuyu/" title="LinkedIn &rarr; https://www.linkedin.com/in/njufuyu/" rel="noopener" target="_blank"><i class="iconfont icon-linkedin"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#子查询简介"><span class="nav-number">1.</span> <span class="nav-text">子查询简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原始执行计划"><span class="nav-number">2.</span> <span class="nav-text">原始执行计划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#apply-算子"><span class="nav-number">3.</span> <span class="nav-text">Apply 算子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本消除规则"><span class="nav-number">4.</span> <span class="nav-text">基本消除规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#project-和-filter-的去关联化"><span class="nav-number">5.</span> <span class="nav-text">Project 和 Filter 的去关联化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aggregate-的去关联化"><span class="nav-number">6.</span> <span class="nav-text">Aggregate 的去关联化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合运算的去关联化"><span class="nav-number">7.</span> <span class="nav-text">集合运算的去关联化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#references"><span class="nav-number">9.</span> <span class="nav-text">References</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Fu</span>

  

  
</div>









        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.7.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  
    
  <script id="dsq-count-scr" src="https://ericfu.disqus.com/count.js" async></script>


<script>
  var disqus_config = function () {
    this.page.url = "https://ericfu.me/subquery-optimization/";
    this.page.identifier = "subquery-optimization/";
    this.page.title = 'SQL 子查询的优化';
    };
  function loadComments () {
    var d = document, s = d.createElement('script');
    s.src = 'https://ericfu.disqus.com/embed.js';
    s.setAttribute('data-timestamp', '' + +new Date());
    (d.head || d.body).appendChild(s);
  }
  
    loadComments();
  
</script>

  





  





  

  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
  

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
  overflow: auto hidden;
}
</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    
  


  

  

  

  

  

  

  

  
  

  
  

  


</body>
</html>
