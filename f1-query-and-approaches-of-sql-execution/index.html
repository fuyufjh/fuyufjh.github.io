<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg?v=5.1.3" color="#222">


  <link rel="manifest" href="/icons/manifest.json">


  <meta name="msapplication-config" content="/icons/browserconfig.xml" />



  <meta name="keywords" content="selected," />





  <link rel="alternate" href="/atom.xml" title="Coding Husky" type="application/atom+xml" />






<meta name="description" content=".image-captain {     margin-top: -20px; }    F1 是起源于 Google AdWords 的分布式 SQL 查询引擎，跟底下的 Spanner 分布式存储搭配，开启了分布式关系数据库——所谓 NewSQL 的时代。我们今天说的是 F1 团队在 VLDB2018 上发的文章 F1 Query: Declarative Querying at Scale">
<meta name="keywords" content="selected">
<meta property="og:type" content="article">
<meta property="og:title" content="从 F1 Query 论文看 SQL 查询的执行模式">
<meta property="og:url" content="https://ericfu.me/f1-query-and-approaches-of-sql-execution/index.html">
<meta property="og:site_name" content="Coding Husky">
<meta property="og:description" content=".image-captain {     margin-top: -20px; }    F1 是起源于 Google AdWords 的分布式 SQL 查询引擎，跟底下的 Spanner 分布式存储搭配，开启了分布式关系数据库——所谓 NewSQL 的时代。我们今天说的是 F1 团队在 VLDB2018 上发的文章 F1 Query: Declarative Querying at Scale">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ericfu.me/images/2018/10/banner-lakeview.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/mysql-thread-group.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/f1-query-valcano.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/f1-query-system-arch.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/f1-query-fragments.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/f1-query-distributed-plan.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/f1-query-plan-to-mr-stages.jpg">
<meta property="og:image" content="https://ericfu.me/images/2018/10/postgres-parallel-query-example.png">
<meta property="og:updated_time" content="2018-10-14T11:39:51.732Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从 F1 Query 论文看 SQL 查询的执行模式">
<meta name="twitter:description" content=".image-captain {     margin-top: -20px; }    F1 是起源于 Google AdWords 的分布式 SQL 查询引擎，跟底下的 Spanner 分布式存储搭配，开启了分布式关系数据库——所谓 NewSQL 的时代。我们今天说的是 F1 团队在 VLDB2018 上发的文章 F1 Query: Declarative Querying at Scale">
<meta name="twitter:image" content="https://ericfu.me/images/2018/10/banner-lakeview.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ericfu.me/f1-query-and-approaches-of-sql-execution/"/>





  <title>从 F1 Query 论文看 SQL 查询的执行模式 | Coding Husky</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-71209065-1', 'auto');
  ga('send', 'pageview');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coding Husky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ericfu.me/f1-query-and-approaches-of-sql-execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Fu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/2015/12/HuskyAvatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coding Husky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从 F1 Query 论文看 SQL 查询的执行模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-14T14:09:12+08:00">
                2018-10-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/f1-query-and-approaches-of-sql-execution/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="f1-query-and-approaches-of-sql-execution/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <style type="text/css">
.image-captain {
    margin-top: -20px;
}
</style>

<p><img src="/images/2018/10/banner-lakeview.jpg" alt=""></p>
<p>F1 是起源于 Google AdWords 的分布式 SQL 查询引擎，跟底下的 Spanner 分布式存储搭配，开启了分布式关系数据库——所谓 NewSQL 的时代。我们今天说的是 F1 团队在 VLDB2018 上发的文章 <a href="http://www.vldb.org/pvldb/vol11/p1835-samwel.pdf" target="_blank" rel="noopener">F1 Query: Declarative Querying at Scale</a>，它和之前我们说的 F1 几乎是两个东西。</p>
<p>F1 Query 是一个分布式的 SQL 执行引擎，现在大数据领域流行的 Presto、Spark SQL、Hive 等等，都可以算在这个范畴里。类似地，F1 Query 也支持对各种不同数据源的查询，既可以是传统的关系表、也可以是 Parquet 这样的半结构化数据。</p>
<a id="more"></a>
<p>这样一来，不同数据格式的壁垒也被打破了：你可以在一个系统里完成对不同数据源的 Join，无论数据以什么形式存放在哪里。商业上管这个叫 Federated Query 或者 DataLake，几家云计算巨头都有类似的产品。</p>
<p><strong>那 F1 Query 的贡献在哪里呢？</strong></p>
<p>F1 Query 定义了三种不同类型的查询执行模式，根据查询的数据量大小或执行时间，将用户查询划分成：</p>
<ol>
<li>单机执行（Centralized Execution）</li>
<li>分布式执行（Distributed Execution）</li>
<li>批处理执行（Batch Execution）</li>
</ol>
<p>前两个是交互式的，即客户端会等待结果返回。最后一个批处理更像是 ETL：客户端输入任务之后就不再管了，查询结果会被写到指定的地方。</p>
<h2 id="单机执行"><a href="#单机执行" class="headerlink" title="单机执行"></a>单机执行</h2><p>单机执行对应我们熟悉的 OLTP 查询，例如单表点查、带索引的 Join 等。这类查询本身已经足够简单，只需几毫秒就能做完，处理它们的最好方式就是在收到请求的机器上立即执行。</p>
<p>在 F1 Query 系统中有 F1 Server 和 F1 Worker 等角色。F1 Server 负责接收客户端请求，如果它判断这个查询应当使用单机而不是分布式方式执行，它就亲力亲为、直接执行并返回结果。</p>
<p>这样的行为和绝大多数单机 OLTP 数据库是一致的，例如 MySQL 采用的是 Thread Pool + Dispatcher 的处理模型，Thread Pool 的规模是一定的，Dispatcher 根据高低优先级分派执行任务。最终一个请求只会被一个线程处理，换句话说，对某个查询来说其执行过程是单线程的。</p>
<p><img src="/images/2018/10/mysql-thread-group.jpg" alt=""></p>
<p class="image-captain">▲ <em>MySQL 的线程池处理模型，一般存在多个 Thread Group，图中描绘了一个 Thread Group</em></p>

<p>F1 Query 单机查询的执行器同样也是教科书式的 Valcano 模型，但也无可厚非——对 OLTP 来说这已经足够好。如下图所示，从顶层算子开始递归地调用 <code>GetNext()</code>，每次取出一行数据，直到没有更多数据为止。各个算子只需要实现 <code>GetNext()</code> 接口即可，简单清晰。</p>
<p><img src="/images/2018/10/f1-query-valcano.jpg" alt=""></p>
<h2 id="分布式执行"><a href="#分布式执行" class="headerlink" title="分布式执行"></a>分布式执行</h2><p>F1 Query 对更复杂的查询，例如没有索引的 Join 或聚合等，则采取分布式查询的方式。大部分 OLAP 查询、尤其是 Ad-hoc 的查询都落在这一分类中。这种情况下，分布式导致的网络、调度等 Overhead 已经远小于查询本身的成本；而且随着数据量的增加，单节点内存显然不够用了。</p>
<p><img src="/images/2018/10/f1-query-system-arch.jpg" alt=""></p>
<p class="image-captain"> ▲ <em>F1 Query 的系统架构，主要包含 F1 Master、F1 Server、F1 Worker 三个角色，其他 Catalog、UDF Server、Batch Metadata 用于存储查询相关的 Metadata 等</em> </p>

<p>这时，上图中的 F1 Worker 就派上用场了。<strong>F1 Server 此时仅仅作为协调者存在，将任务分配给多个 Worker</strong>，直到 Worker 的任务全都完成，再把结果汇总发给客户端。</p>
<p>这个模式眼熟吗？你可能会想到 Greenplum 这类的数据仓库，已经很接近了。最相似的我认为是 Presto。Presto 是 Facebook 开发的一套分布式 SQL 引擎，如果单单只看 F1 Query 的分布式查询，和 Presto 大同小异。</p>
<p>与单机执行不同的是，<strong>分布式查询中的算子可以有多个实例（Instance）并行执行，每个实例负责其中一部分数据</strong>。在 F1 Query 里这样一个数据分片被称为 Fragment，在 Spark SQL 里叫 Partition，在 Presto 里叫 Split。</p>
<p><img src="/images/2018/10/f1-query-fragments.jpg" alt=""></p>
<p>下面的例子是一个 Join-Aggregation-Sort 的查询，它分成了 4 个阶段：</p>
<ol>
<li><code>Scan(Clicks)</code> 被分配给 1000 个 F1 Worker 上并行拉取数据，并根据每一行数据的 <code>Hash(AdID)</code> 发送给对应的 <code>HashJoin</code> 分片，即一般说的 shuffle 过程;</li>
<li><code>Scan(Ads)</code> 被分配给 200 个 F1 Worker 上并行拉取数据，并且也以同样的方式做 shuffle；</li>
<li><code>HashJoin</code> 及 <code>PartialAggregation</code>：根据 Join Key 分成了 1000 个并行任务，各自做 Join 计算，并做一次聚合；</li>
<li>最后，F1 Server 把各个分片的聚合结果再汇总起来，返回给客户端。</li>
</ol>
<p><img src="/images/2018/10/f1-query-distributed-plan.jpg" alt=""></p>
<p>Presto 具有的缺陷，F1 Query 分布式查询同样也有，比如：</p>
<ul>
<li>纯内存的计算方式，无法利用磁盘的存储空间，某些查询可能面临内存不足；</li>
<li>没有 Fault-tolerance，对于一个涉及上千台 Worker 的查询，任何一台的重启都会导致查询失败。</li>
</ul>
<h2 id="批处理执行"><a href="#批处理执行" class="headerlink" title="批处理执行"></a>批处理执行</h2><p>F1 Query 还有个独特的批处理执行，这个模式定位于更大的数据量、更久的查询时间；另一方面，它的结果不再是返回给客户端，而是将查询结果写到指定的地方，例如 Colossus（第二代 GFS）上。</p>
<p>上一节我们提道，Presto 的模式没有 Fault-tolerance，这对于长时间运行的批处理任务是致命的，查询失败的概率会大大增加。批处理查询首先要解决的就是 Fault-tolerance 问题：<strong>必须能以某种方式从 Worker 节点的失败中恢复</strong>。</p>
<p>解决这个问题有两条路可走：一是 MapReduce 的模式，将计算分成若干个阶段（Stage），而中间结果持久化到 HDFS 这样的分布式文件系统上；二是 Spark RDD 模式，通过记录祖先（Lineage）信息，万一发生节点失败，就通过简单的重算来恢复丢失的数据分片，这样数据就可以放在内存里不用落盘。</p>
<p>Spark 的做法显然是更先进的，原因有很多，这里只说最重要的 2 条。欲知详情可以看我之前的博客文章<a href="https://ericfu.me/apache-spark-in-nutshell/">《一文读懂 Apache Spark》</a>。</p>
<ol>
<li>Spark 的计算基本在内存中，只有当内存不够时才会溢出到磁盘，而 MR 的中间结果必须写入外部文件系统；</li>
<li>Spark 可以把执行计划 DAG 中相互不依赖的 Stage 并行执行，而 MR 只能线性地一个接一个 Stage 执行。</li>
</ol>
<p>但是出乎意料的是，F1 Query 采用的是前者，也就是 MR 模式。这其中的原因我们不得而知，我猜想和 Google 自家的 FlumeJava 不够给力有关系。</p>
<p>如下图。左边的 Physical Plan 和上一节的分布式查询是一样的，不同之处是<strong>在批处理模式下，它被转换成一系列的 MR 任务</strong>，之后交给调度器（Scheduler）去处理即可。</p>
<p><img src="/images/2018/10/f1-query-plan-to-mr-stages.jpg" alt=""></p>
<p>相比分布式执行，批处理模式下各个步骤都会持久化到外部文件系统（因为 MapReduce 的特性所致）。不仅如此，<strong>Pipeline 式的执行也没法进行</strong>。以上一节提到的 HashJoin 为例，左边 <code>Clicks</code> 的 Scan 和 HashJoin 原本是可以 Pipeline 执行的，但是在批处理模式下，必须等到 <code>Scan(Clicks)</code> 这个阶段完成才能进行下一步的 HashJoin 阶段。</p>
<h2 id="单机并行执行"><a href="#单机并行执行" class="headerlink" title="单机并行执行"></a>单机并行执行</h2><p>除了上面聊的 F1 Query 所支持的 3 种查询模式之外，事实上还有一种处理模型位于单线程执行和分布式执行之间：单机的并行执行。初看这似乎与分布式执行很相似，但又有些不同：</p>
<ul>
<li>不用考虑单个 Worker 的失败恢复，因为它们都在同一个进程里；</li>
<li>各个 Worker 线程的内存是共享的，它们之间交换数据无需考虑网络通讯代价。</li>
</ul>
<p>这种模式在传统的关系型数据库上很常见，尤其是 Postgres、SQL Server 这类以 OLAP 查询见长的选手。以 Postgres 为例，在开启并行查询的情况下，查询优化器会根据代价选择是否生成并行执行计划；如果生成了并行执行计划，执行器会调度多个 Worker 一起完成工作。</p>
<p>下图是一个 Postgres 上并行 Hash Join 的例子，从执行计划上看和上一节几乎一样，但是这里不再需要对数据做 Shuffle：Hash Join 所用的 Hash Table 本身是全局共享的。</p>
<p><img src="/images/2018/10/postgres-parallel-query-example.png" alt="postgres-parallel-query-example"></p>
<blockquote>
<p>Parallel Hash Join 并非只有这一种做法。SQL Server 就更接近分布式执行的方案：把 Hash Key 相同的数据 shuffle 到同一个分片上——但这个 shuffle 只是逻辑上的，不需要真的做 IO。</p>
</blockquote>
<p>相比分布式查询，<strong>单机并行的最大优势在于响应速度更快</strong>，因为省去了大量的网络 IO 时间，而且调度一个 Worker 线程要比调度一个 Worker 机器快得多。</p>
<p>但别忘了，单机运算能力的 scale up 成本非常高，并且是存在上限的。对于 Google 之类的互联网公司，绝大部分查询都超出了单机的存储或计算能力，我猜测这也是 F1 Query 并未考虑单机并行的理由。</p>
<h2 id="对-F1-Query-的评价"><a href="#对-F1-Query-的评价" class="headerlink" title="对 F1 Query 的评价"></a>对 F1 Query 的评价</h2><p>从论文描述的情况来看，F1 Query 还不算个完善、成熟的系统，其定位更像是一个解决业务需求的胶水系统，而非 Spanner 这样的“硬核”技术。它追求的是够用就好。很多地方其实还有不小的改进空间，举几个例子：</p>
<ul>
<li>对交互式查询，选择分布式还是单机计算目前还是基于启发式规则。</li>
<li>三种模式的执行计划是用一样的优化器生成的。但是客观的说，这其中的差别可是不小的。</li>
<li>优化器是基于规则的。之所以不做 CBO，论文给出的解释是数据源众多，不容易估算代价。</li>
<li>批处理模式下用 Spark 取代 MR 的模式是更好的选择。</li>
</ul>
<p>F1 Query 希望<strong>用一套系统解决所有 OLTP、OLAP、ETL 需求、用一套系统访问数据中心里各种格式的数据</strong>，这两点才是 F1 Query 的核心竞争力。</p>
<h2 id="SQL-执行模式总结"><a href="#SQL-执行模式总结" class="headerlink" title="SQL 执行模式总结"></a>SQL 执行模式总结</h2><p>从数据库的视角看，理想的数据库应当隐藏掉查询执行的种种细节，只要用户输入一个声明（例如 SQL），就能以最优的方式执行查询给出答案。F1 Query 做了个勇敢的尝试，<strong>它将多种执行模型揉合在一个系统中，共享同一套优化器和算子</strong>，以较低的开发成本获得其中最优的执行性能（在理想情况下）。</p>
<p>下面的表格总结了 4 种执行模式的优势和不足。</p>
<table>
<thead>
<tr>
<th></th>
<th>单线程</th>
<th>单机并行</th>
<th>分布式并行</th>
<th>批处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>代表系统</td>
<td>MySQL / Oracle</td>
<td>Postgres / MSSQL</td>
<td>Presto / Greenplum</td>
<td>Spark / Hive</td>
</tr>
<tr>
<td>硬件架构</td>
<td>单核</td>
<td>SMP / NUMA</td>
<td>MPP</td>
<td>MPP</td>
</tr>
<tr>
<td>伸缩性</td>
<td>无</td>
<td>Scale Up</td>
<td>弹性 Scale Out</td>
<td>弹性 Scale Out</td>
</tr>
<tr>
<td>Fault-Toralence</td>
<td>无</td>
<td>无</td>
<td>重试整个查询</td>
<td>Worker 级 fail-over</td>
</tr>
<tr>
<td>典型数据量</td>
<td>若干个 Tuple</td>
<td>单机内存可容纳</td>
<td>大数据</td>
<td>大数据</td>
</tr>
<tr>
<td>典型响应时间</td>
<td>毫秒</td>
<td>数百毫秒</td>
<td>秒级</td>
<td>秒级到数小时</td>
</tr>
</tbody>
</table>
<p>总而言之，所谓 <a href="https://en.wikipedia.org/wiki/No_free_lunch_theorem" target="_blank" rel="noopener"><em>No Free Launch</em></a> —— 没有最优的方案，<strong>数据量是决定能选用哪个执行模式的前提</strong>。实践中，先确保数据量能够承载的下，再谈优化也就明白多了。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="http://www.vldb.org/pvldb/vol11/p1835-samwel.pdf" target="_blank" rel="noopener">F1 Query: Declarative Querying at Scale</a></li>
<li><a href="https://www.programering.com/a/MTO5YDMwATI.html" target="_blank" rel="noopener">MySQL Thread Pool Implementation</a></li>
<li><a href="https://tech.meituan.com/presto.html" target="_blank" rel="noopener">Presto 实现原理和美团的使用实践 - 美团技术团队</a></li>
</ol>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Eric Fu
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://ericfu.me/f1-query-and-approaches-of-sql-execution/" title="从 F1 Query 论文看 SQL 查询的执行模式">https://ericfu.me/f1-query-and-approaches-of-sql-execution/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/apache-spark-in-nutshell/" rel="next" title="一文读懂 Apache Spark">
                <i class="fa fa-chevron-left"></i> 一文读懂 Apache Spark
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/2015/12/HuskyAvatar.jpg"
                alt="Eric Fu" />
            
              <p class="site-author-name" itemprop="name">Eric Fu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/fuyufjh" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/fuyufjh" target="_blank" title="Zhihu">
                    
                      <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/fuyufjh" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.crazyark.me/" title="crazy.ark" target="_blank">crazy.ark</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kaimingwan.com/" title="Blog of Kami Wan" target="_blank">Blog of Kami Wan</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#单机执行"><span class="nav-number">1.</span> <span class="nav-text">单机执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式执行"><span class="nav-number">2.</span> <span class="nav-text">分布式执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理执行"><span class="nav-number">3.</span> <span class="nav-text">批处理执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单机并行执行"><span class="nav-number">4.</span> <span class="nav-text">单机并行执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对-F1-Query-的评价"><span class="nav-number">5.</span> <span class="nav-text">对 F1 Query 的评价</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL-执行模式总结"><span class="nav-number">6.</span> <span class="nav-text">SQL 执行模式总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">7.</span> <span class="nav-text">References</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric Fu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  

    
      <script id="dsq-count-scr" src="https://ericfu.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://ericfu.me/f1-query-and-approaches-of-sql-execution/';
          this.page.identifier = 'f1-query-and-approaches-of-sql-execution/';
          this.page.title = '从 F1 Query 论文看 SQL 查询的执行模式';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://ericfu.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
